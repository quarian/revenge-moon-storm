<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style>
body {
    max-width: 1024px;
    margin: auto;
    font-size: 12pt;
}
.code {
    font-family: monospace;
    font-weight: bold;
    font-size: 10pt;
}
.tb1 {
    vertical-align: top;
    font-weight: bold;
}
.tb2 { vertical-align: top; }
#gamemodes, #tasks {
    width: 80%;
    margin: auto;
}
</style>
<title>AS-0.3302 Project document</title>
</head>

<body>

<div style="text-align: center">
<h3>AS-0.3302 - project document</h3>
<h1>Revenge of the Moon &mdash; The Gathering Storm</h1>
</div>

<h3>Authors:</h3>

<table>
<tr>
<td>84745F</td>
<td>Miro Nurmela</td>
<td><a href="miro.nurmela@aalto.fi">miro.nurmela@aalto.fi</a></td>
</tr>
<tr>
<td>290658</td>
<td>Henri Niva</td>
<td><a href="henri.niva@aalto.fi">henri.niva@aalto.fi</a></td>
</tr>
<tr>
<td>84312L</td>
<td>Joonas Lipping</td>
<td><a href="joonas.lipping@aalto.fi">joonas.lipping@aalto.fi</a></td>
</tr>
<tr>
<td>78740E</td>
<td>Roope Savolainen</td>
<td><a href="roope.savolainen@aalto.fi">roope.savolainen@aalto.fi</a></td>
</tr>
</table>

<h3>Last updated: </h3>

<p>2013-12-11</p>







<h2>Instructions for compiling and use</h2>

<p>
The project should be compiled from the <span class="code">/src</span> folder
with the command <span class="code">make</span>, 
building the default target (<span class="code">all</span>).

To ensure compatibility with school computers,
the default target for <span class="code">make</span>
uses a portable copy of SFML located in the <span class="code">/src/SFML</span> folder.
The <span class="code">alt</span> target for <span class="code">make</span>
attempts to use system libraries instead.

Both targets create an executable titled <span class="code">minebombers</span>.

You can also compile a simple map editor by running <span class="code">make editor</span>.
This creates an executable called <span class="code">editor</span>, which must be run with
one command line argument. The command line argument defines the name of the map you
are editing. If an existing map is given as an argument you can modify that, otherwise when you save
the map a new file is created. Map names are interpreted relative to the <span class="code">maps</span>
folder.
</p>


<p>
The program opens into a main menu that can be navigated by arrow keys.
The return key selects menu options.
Two game modes are available:
</p>

<table id="gamemodes">
    <tr>
        <td class="tb1"><b>Campaign game</b></td>
         <td class="tb2">
             This is the game's "story mode", consisting of four levels.
             The year is 2061.
             You work at the New Thiggrinc lunar mining colony,
             supplying the precious element MacCuffinium that powers the world economy.
             One day, disaster strikes...
         </td>
    </tr>
    <tr>
        <td class="tb1"><b>Multiplayer game</b></td>
         <td class="tb2">
             Two-player hotseat game on a randomly generated map.
             Collect the most scrap to win.
         </td>
    </tr>
</table>

<p>
The campaign game opens directly into the game world.
The player controls the moon astronaut character with the arrow keys.
There are different terrains on the map, some of which are diggable.
Digging works by "walking into" the target tile.
The map also contains different monsters which will try to damage the player.
Keep away from them or destroy them by using weapons.
Pressing the space bar uses the currently equipped weapon,
and the left alt key changes weapons.
The goal is to get to the next level.
The level exit is located in the upper right corner of the screen.
</p>

<p>
During the level, you will see pieces of scrap lying around.
Collecting scrap lets you craft more items in the Workshop.
After you pass a level, or if you happen to die during the level,
you are taken to the Workshop screen.
You use the same keys in the workshop as you move with, the "fire weapon" key to buy
and the "change weapon" key to sell. Items can be salvaged into the same materials
as they are crafted from.
</p>

<p>
In the multiplayer game mode, the goal is to collect more scrap than the other player
or to destroy the other player. Unlike in the campaign mode, the store is presented
at the start of each round. One player at a time can use the store,
and they use the same keys in the store as they do in the game.
Player 1 uses the arrow keys to move and right Ctrl to fire, right Shift to change weapons;
Player 2 uses the WASD keys to move and Spacebar to fire, left Alt to change weapons.
</p>

<p>
In the editor you can place elements to the map by using your mouse. You can add multiple
blocks by holding the left mouse button and dragging the mouse. You can change the type
of element added by using the appropriate keys shown in the bottom of the screen. Press
<span class="code">s</span> to save to the file you supplied on startup.
</p>

<!--
<p>In this chapter you must tell which platform(s) and operating system(s) your program supports.
How it can be compiled (and installed) ie. which tools are needed to compile the program and which commands to use.
</p>

<p>You must also tell what your program does and how it can be used. You must also add some
example of program runs (example inputs and outputs and/or screenshots or something like that).</p>

<p>Add here the manual of your program.</p>

<p><b>This part is important. If the assistant can not understand how to compile and/or use your program by
reading these instructions, your project will most propably be failed.</b></p>
-->










<h2>Program architechture</h2>

<!-- In this chapter you must describe the main architechture of your program. You <b>must draw</b> clear diagrams
of your program structure. You don't need to go in to the details, but this chapter should give the reader
the idea of the architechture of your program. You must also tell, why you decided to use the architechture you used. -->

<p>
The architecture of RotM is conceptually divided, roughly speaking, into four domains.
An administrative system manages resources and handles state transitions.
The map architecture manages the grid-based game levels and their representation,
and the map object system encompasses monsters, treasures, bombs, etc.
The world controller drives the game loop on a given game level.
It can be thought of as a bridge between the administrative system and the map architecture,
because it has properties characteristic of both of these,
but since it is conceptually a separate entity, it is here treated as such.
</p>

<h3>The administrative system</h3>

<p>
The entire program is contained within a single <span class="code">Game</span> object.
When it is constsructed, it initializes an
<span class="code">EventManager</span>, a
<span class="code">GraphicsManager</span> and a
<span class="code">TerrainManager</span>.
It makes all three available for other parts of the program throughout its operation.
(The program also makes use of a <span class="code">MapObjectManager</span>,
which is stateless and can therefore just be represented as a two-function namespace
that is globally available (as namespaces are).)
The graphics, terrain, and map object managers are resource managers.
The event manager's function is to handle input events (keyboard commands and window events).
</p>

<p>
After the <span class="code">Game</span> object has taken care of its initial housekeeping,
its member function <span class="code">Game::main()</span> is run.
Excluding game and manager object destructors, this function drives the rest of the program.
The different game states, represented by <span class="code">GameState</span> objects,
form a state stack structure.
When the game starts, a <span class="code">MainMenu</span> state is pushed onto the stack and starts receiving input.
Depending on the user's input, it can spawn a number of different states,
such as <span class="code">CampaignGame</span> and <span class="code">MultiplayerGame</span>.
When such a state is spawned, it gets pushed onto the state stack and becomes the active state.
It remains active until it either spawns another state and transfers control to it,
or terminates and returns control to the state that spawned it.
When the last element on the stack terminates and gets popped, the program terminates &mdash;
that is, when the main menu exits, so does the program.
</p>

<img src="gamestates.svg" width="100%" />

<h3>The world controller</h3>

<p>

</p>

<h3>The map architecture</h3>

<p>
A <span class="code">Map</span> is represented as a two dimensional grid (implemented as standard C++
<span class="code">vectors</span>) <span class="code">MapBlocks</span>. Both <span class="code">Map</span> and
<span class="code">MapBlock</span> offer functions and utilites to both get information about the current map
and modify the state of maps and its blocks &mdash; these features are discussed here.

During a game of RoTM the map holds the information about what is going on in the battlefield, such as players,
monsters, items and terrain features. Coincidentially the map blocks also hold the information on who resides in
the given block. More on this on the next chapter.

The <span class="code">Map</span> has a few methods for creating random maps. Specifically, it can create maps
with random rooms and maps with mazes. The generation algorithms are discussed in more detail on the algorithms
section. Other utility algorthms on the map include the computation of line of sight (more on this too on the
algorithms section), radius calculations and various other, simple methods.


</p>

<h3>The map object system</h3>

<p> 
The game level, as represented by the <span class="code">Map</span> and
<span class="code">MapBlock</span> classes, understands its dynamic contents
&mdash; that is, interactive objects beyond simple terrain &mdash;
as <span class="code">Player</span>,
<span class="code">Walker</span> or
<span class="code">Item</span> objects.
Walkers represent characters, mainly monsters, who move around the map at some
given speed. Items represent generally (though not strictly) stationary objects:
collectible treasures, dropped bombs and event-triggering fixtures (and
certain other entities that are not obviously item-like, but are represented as such for convenience,
such as explosions).
Both categories of objects expose an <span class="code">update(dt)</span> method
which the loop of the world controller calls on each pass.
</p>

<p>
<span class="code">Player</span> objects carry information about name, number of lives and inventory,
and are able to spawn walkers as needed to act as avatars.
Players are (from the point of view of the map architecture)
mostly degenerate with walkers, in that most of the time the controller
just wants to access the player's associated walker in order to tell it to update itself.
Players and walkers are handled separately mainly because otherwise there would be no good way to tell
whether a walker is associated with a player, and if so, which one.
</p>

<p>
Usually, a <span class="code">Walker</span> object is also an <span class="code">Actor</span>.
The <span class="code">Actor</span> class, which inherits <span class="code">Walker</span>,
provides additional functionalities of health, digging, etc.
These have been left out of <span class="code">Walker</span> for the sake of generality:
this way, <span class="code">Walker</span> can, if necessary,
act as a subclass for objects such as projectiles, for which digging
and health are not meaningful properties.
<span class="code">Actor</span> is further inherited by
<span class="code">ControlledActor</span> and <span class="code">AIActor</span>,
which represent keyboard-controlled and computer-controlled characters,
respectively.
Controlled actors provide methods that other objects can use to
inform them of the controller state (which keys are pressed),
while AI actors use an internal logic, managed by their <span class="code">update()</span>
methods, that "plans ahead" what they're going to do.
In general, when an AI actor is updated, it follows its existing plan if it has one;
if the plan runs out, it calls its <span class="code">think()</span>
method, which hatches a new one.
</p>

<p>
<span class="code">Item</span> objects are almost entirely self-organizing.
Their constructors automatically add them to the relevant <span class="code">Map</span>
and <span class="code">MapBlock</span>, and their destructors remove them from the same.
They only need to be <span class="code">new</span>ed and <span class="code">delete</span>d "by hand".
Walkers handle their map tiles on their own,
but the map's set of walkers needs to be "garbage collected" by another routine.
</p>







<h2>Data structures and algorithms</h2>

<h3>Map generation algorithms</h3>

RotM sports two kinds of random map generation algorithms - one that creates random rooms and one that
creates random mazes. The random room algorithm works as follows:

<ol>
    <li>Create borders for the map</li>
    <li>Fill the map with empty blocks</li>
    <li>Create a single room somewhere on the map with random terrain walls</li>
    <li>Randomly decide a new room to add</li>
    <li>Try adding the feature</li>
    <li>If adding failed, go to step 3</li>
    <li>Otherwise, add feature</li>
    <li>Go to step 3 if the stoppping condition has not been met</li>
    <li>Throw in some items randomly on the map</li>
</ol>

The maze generation algorithm works by recursively dividing rooms into smaller rooms. This results
in good mazes gameplaywise (enough room to maneuver). The algorithm works as follows:

<p>
<span class="code">define divide(x_min, x_max, y_min, y_max)</span><br/>
&nbsp;&nbsp;<span class="code">if (x_max - x_min smaller than threshold or y_max - y_min smaller than threshold)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">return</span><br/>
&nbsp;&nbsp;<span class="code">horizontal = randInt % 2</span><br/>
&nbsp;&nbsp;<span class="code">if (horizontal)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">add a wall at random y coordinate between y_min and y_max and add door somewhere in the wall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x_max, y_min, y)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x_max, y, y_max)</span><br/>
&nbsp;&nbsp;<span class="code">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">add a wall at random x coordinate between x_min and x_max and add door somewhere in the wall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x, y_min, y_max)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x, x_max, y_min, y_max)</span><br/>
</p>

<p>
There are some additional checks in the algorithm to ensure that the doors are not blocked, but this is the basic
idea of the algorithm.
</p>

<h3>Line of sight algorithm</h3>

<p>
The program calculates the line of sight using a modified vestion of Bresenham's line algorithm (see the
<a href="#refs">references</a> for a reference). The original Bresenham's algorithm twists the numbres
around such that it can always increment the value that loops through the pixels - we don't want this
kind of behaviour, since we want all the lines to start from the player (and not end there, as would
be the case of some view lines if we were to use the original Bresenham's algorithm). In practice the
program tries to draw a line to every border block and as long as there is nothing on the way, it marks
those blocsk visible. Drawing of the line ends as soon as it hits something impassable.
)
</p>
<!--
<p>In this chapter you must describe the data structures and algorithms used in your program. Dont't put
your code here, but describe the data structures and algorithms using natural language (you can also add pictures).</p>
-->

<h2>Known bugs</h2>

<p>
NO. EVERYTHING IS PERFECT.
</p>

<!--
<p>In this chapter you must tell all known bugs in your code. You must also tell what could have been done better.</p>

<p>If the assistant finds bug(s) in your code that you haven't mentioned, it is very bad thing and your points will be
decreased. And if your code segfaults, it is even worse and your points will be decreased more...</p>
-->

<h2>Tasks sharing and schedule</h2>

<table id="tasks">
    <tr><td class="tb1">Miro</td>
        <td class="tb2">
            <span class="code">Map</span> and <span class="code">MapBlock</span> implementations<br/>
            Map generation (stuff lives in <span class="code">Map</span>)<br/>
            Line of sight (in <span class="code">MapUtils</span>)<br/>
            Map editor (in <span class="code">MapEditor</span> and <span class="code">EditorInterface</span>)<br/>
        </td>
    </tr>
    <tr><td class="tb1">Henri</td>
        <td class="tb2">
	    <span class="code">Item</span> class and most of its derivates, such as
        <span class="code">Weapons</span>,<br/> animations and effects.<br/>
	    <span class="code">Inventory</span> and <span class="code">Store</span> implementations.<br/>
	    Game graphics.<br/>
        </td>
    </tr>
    <tr><td class="tb1">Joonas</td>
        <td class="tb2">
            <span class="code">Walker</span> and all inheriting classes; <span class="code">Player</span>; enemy AI<br/>
            <span class="code">GameState</span> base class and mechanism; <span class="code">CampaignGame</span><br/>
            <span class="code">KeyInterface</span> base class and mechanism; <span class="code">PlayerInterface</span><br/>
            <span class="code">TerrainManager</span>, 
            <span class="code">MapObjectManager</span><br/>
            A* pathfinding algorithm implementation<br/>
            Map fixtures<br/>
        </td>
    </tr>
    <tr><td class="tb1">Roope</td>
        <td class="tb2">
            <span class="code">Game</span>,
            <span class="code">EventManager</span>,
            <span class="code">GraphicsManager</span>,
            <span class="code">WindowManager</span><br/>
            Game menus and graphics<br/>
        </td>
    </tr>
</table>

<!--
<p>In this chapter you must tell how the task sharing and communication inside the group worked.
You must also tell the real schedule and amount of work done by each group member. You are also encouraged to describe the amount of work of each different part you your project. (planning, implementation of different areas of project, testing and documentation etc.)</p>

<p>Think and tell also, if you could have shared tasks better. What went wrong compared to the schedule of your original
plan and why.</p>
-->

<h2>Differences to the original plan</h2>

<p>
The original plan had us iterating on a basically functional program throughout the development process.
This noble goal was sabotaged by early difficulties in building the administrative and world controller parts,
meaning that in reality, it was a couple of weeks before we were able to scramble together a working iteration.
This also led to challenges when developing the map architecture,
because code sanity checks had to take the form of specially written unit tests
as opposed to just plopping something on the map and seeing if it does what it ought to.
</p>

<!--
<p>In this chapter you must tell what is done in different way that was originally planned and why.</p>

<p>Do you think your plan was good enough, super, or should you have planned your program better?</p>
-->
<div id="refs">
    <h2>References</h2>

    <p>In this chapter you must tell all the references you have used during your project.</p>

    <p>Bresenham's line algorihm, <a href="http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Wikipedia on Bresenham's line algorithm</a>, read 11.12.2013</p>
    <p>Things about maze generation, <a href="http://en.wikipedia.org/wiki/Maze_generation_algorithm">Wikipedia on maze generation</a>, read 11.12.2013</p>
    <p>Ideas on map generation, <a href="http://pcg.wikidot.com/pcg-algorithm:dungeon-generation">Dungeon generation algorithms</a>, read 11.12.2013</p>
    <p>A* pathfinding algorithm, <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia</a>, read 12.12.2013</p>
</div>

</body>
</html>

