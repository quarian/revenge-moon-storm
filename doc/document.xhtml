<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style>
body {
    max-width: 1024px;
    margin: auto;
    font-size: 12pt;
}
.code {
    font-family: monospace;
    font-weight: bold;
    font-size: 10pt;
}
.tb1 {
    vertical-align: top;
    font-weight: bold;
}
.tb2 { vertical-align: top; }
#gamemodes, #tasks {
    width: 80%;
    margin: auto;
}
</style>
<title>AS-0.3302 Project document</title>
</head>

<body>

<div style="text-align: center">
<h3>AS-0.3302 - project document</h3>
<h1>Revenge of the Moon &mdash; The Gathering Storm</h1>
</div>

<h3>Authors:</h3>

<table>
<tr>
<td>84745F</td>
<td>Miro Nurmela</td>
<td><a href="miro.nurmela@aalto.fi">miro.nurmela@aalto.fi</a></td>
</tr>
<tr>
<td>290658</td>
<td>Henri Niva</td>
<td><a href="henri.niva@aalto.fi">henri.niva@aalto.fi</a></td>
</tr>
<tr>
<td>84312L</td>
<td>Joonas Lipping</td>
<td><a href="joonas.lipping@aalto.fi">joonas.lipping@aalto.fi</a></td>
</tr>
<tr>
<td>78740E</td>
<td>Roope Savolainen</td>
<td><a href="roope.savolainen@aalto.fi">roope.savolainen@aalto.fi</a></td>
</tr>
</table>

<h3>Last updated: </h3>

<p>2013-12-11</p>







<h2>Instructions for compiling and use</h2>

<p>
The project should be compiled from the <span class="code">/src</span> folder
with the command <span class="code">make</span>, 
building the default target (<span class="code">all</span>).

To ensure compatibility with school computers,
the default target for <span class="code">make</span>
uses a portable copy of SFML located in the <span class="code">/src/SFML</span> folder.
The <span class="code">alt</span> target for <span class="code">make</span>
attempts to use system libraries instead.

Both targets create an executable titled <span class="code">minebombers</span>.
</p>


<p>
The program opens into a main menu that can be navigated by arrow keys.
The return key selects menu options.
Two game modes are available:
</p>

<table id="gamemodes">
    <tr>
        <td class="tb1"><b>Campaign game</b></td>
         <td class="tb2">
             This is the game's "story mode", consisting of four levels.
             The year is 2061.
             You work at the New Thiggrinc lunar mining colony,
             supplying the precious element MacCuffinium that powers the world economy.
             One day, disaster strikes...
         </td>
    </tr>
    <tr>
        <td class="tb1"><b>Multiplayer game</b></td>
         <td class="tb2">
             Two-player hotseat game on a randomly generated map.
             Collect the most gold to win.
         </td>
    </tr>
</table>


<!--
<p>In this chapter you must tell which platform(s) and operating system(s) your program supports.
How it can be compiled (and installed) ie. which tools are needed to compile the program and which commands to use.
</p>

<p>You must also tell what your program does and how it can be used. You must also add some
example of program runs (example inputs and outputs and/or screenshots or something like that).</p>

<p>Add here the manual of your program.</p>

<p><b>This part is important. If the assistant can not understand how to compile and/or use your program by
reading these instructions, your project will most propably be failed.</b></p>
-->










<h2>Program architechture</h2>

<!-- In this chapter you must describe the main architechture of your program. You <b>must draw</b> clear diagrams
of your program structure. You don't need to go in to the details, but this chapter should give the reader
the idea of the architechture of your program. You must also tell, why you decided to use the architechture you used. -->

<p>
The architecture of RotM is conceptually divided, roughly speaking, into four domains.
An administrative system manages resources and handles state transitions.
The map architecture manages the grid-based game levels and their representation,
and the map object system encompasses monsters, treasures, bombs, etc.
The world controller drives the game loop on a given game level.
It can be thought of as a bridge between the administrative system and the map architecture,
because it has properties characteristic of both of these,
but since it is conceptually a separate entity, it is here treated as such.
</p>

<h3>The administrative system</h3>

<p>
The entire program is contained within a single <span class="code">Game</span> object.
When it is constsructed, it initializes an
<span class="code">EventManager</span>, a
<span class="code">GraphicsManager</span> and a
<span class="code">TerrainManager</span>.
It makes all three available for other parts of the program throughout its operation.
(The program also makes use of a <span class="code">MapObjectManager</span>,
which is stateless and can therefore just be represented as a two-function namespace
that is globally available (as namespaces are).)
The graphics, terrain, and map object managers are resource managers.
The event manager's function is to handle input events (keyboard commands and window events).
</p>

<p>
After the <span class="code">Game</span> object has taken care of its initial housekeeping,
its member function <span class="code">Game::main()</span> is run.
Excluding game and manager object destructors, this function drives the rest of the program.
The different game states, represented by <span class="code">GameState</span> objects,
form a state stack structure.
When the game starts, a <span class="code">MainMenu</span> state is pushed onto the stack and starts receiving input.
Depending on the user's input, it can spawn a number of different states,
such as <span class="code">CampaignGame</span> and <span class="code">MultiplayerGame</span>.
When such a state is spawned, it gets pushed onto the state stack and becomes the active state.
It remains active until it either spawns another state and transfers control to it,
or terminates and returns control to the state that spawned it.
When the last element on the stack terminates and gets popped, the program terminates &mdash;
that is, when the main menu exits, so does the program.
</p>

<img src="gamestates.svg" width="100%" />

<h3>The world controller</h3>

<p>

</p>

<h3>The map architecture</h3>

<p>
</p>

<h3>The map object system</h3>

<p> 
The game level, as represented by the <span class="code">Map</span> and
<span class="code">MapBlock</span> classes, understands its dynamic contents
&mdash; that is, interactive objects beyond simple terrain &mdash;
as <span class="code">Player</span>,
<span class="code">Walker</span> or
<span class="code">Item</span> objects.
Walkers represent characters, mainly monsters, who move around the map at some
given speed. Items represent generally (though not strictly) stationary objects:
collectible treasures, dropped bombs and event-triggering fixtures (and
certain other entities that are not obviously item-like, but are represented as such for convenience,
such as explosions).
Both categories of objects expose an <span class="code">update(dt)</span> method
which the loop of the world controller calls on each pass.
</p>

<p>
<span class="code">Player</span> objects carry information about name, number of lives and inventory,
and are able to spawn walkers as needed to act as avatars.
Players are (from the point of view of the map architecture)
mostly degenerate with walkers, in that most of the time the controller
just wants to access the player's associated walker in order to tell it to update itself.
Players and walkers are handled separately mainly because otherwise there would be no good way to tell
whether a walker is associated with a player, and if so, which one.
</p>

<p>
Usually, a <span class="code">Walker</span> object is also an <span class="code">Actor</span>.
The <span class="code">Actor</span> class, which inherits <span class="code">Walker</span>,
provides additional functionalities of health, digging, etc.
These have been left out of <span class="code">Walker</span> for the sake of generality:
this way, <span class="code">Walker</span> can, if necessary,
act as a subclass for objects such as projectiles, for which digging
and health are not meaningful properties.
<span class="code">Actor</span> is further inherited by
<span class="code">ControlledActor</span> and <span class="code">AIActor</span>,
which represent keyboard-controlled and computer-controlled characters,
respectively.
Controlled actors provide methods that other objects can use to
inform them of the controller state (which keys are pressed),
while AI actors use an internal logic, managed by their <span class="code">update()</span>
methods, that "plans ahead" what they're going to do.
In general, when an AI actor is updated, it follows its existing plan if it has one;
if the plan runs out, it calls its <span class="code">think()</span>
method, which hatches a new one.
</p>

<p>
<span class="code">Item</span> objects are almost entirely self-organizing.
Their constructors automatically add them to the relevant <span class="code">Map</span>
and <span class="code">MapBlock</span>, and their destructors remove them from the same.
They only need to be <span class="code">new</span>ed and <span class="code">delete</span>d "by hand".
Walkers handle their map tiles on their own,
but the map's set of walkers needs to be "garbage collected" by another routine.
</p>







<h2>Data structures and algorithms</h2>

<!--
<p>In this chapter you must describe the data structures and algorithms used in your program. Dont't put
your code here, but describe the data structures and algorithms using natural language (you can also add pictures).</p>
-->

<h2>Known bugs</h2>

<p>
NO. EVERYTHING IS PERFECT.
</p>

<!--
<p>In this chapter you must tell all known bugs in your code. You must also tell what could have been done better.</p>

<p>If the assistant finds bug(s) in your code that you haven't mentioned, it is very bad thing and your points will be
decreased. And if your code segfaults, it is even worse and your points will be decreased more...</p>
-->

<h2>Tasks sharing and schedule</h2>

<table id="tasks">
    <tr><td class="tb1">Miro</td>
        <td class="tb2">
        </td>
    </tr>
    <tr><td class="tb1">Henri</td>
        <td class="tb2">
        </td>
    </tr>
    <tr><td class="tb1">Joonas</td>
        <td class="tb2">
            <span class="code">Walker</span> and all inheriting classes; <span class="code">Player</span>; enemy AI<br/>
            <span class="code">GameState</span> base class and mechanism; <span class="code">CampaignGame</span><br/>
            <span class="code">KeyInterface</span> base class and mechanism; <span class="code">PlayerInterface</span><br/>
            <span class="code">TerrainManager</span>, 
            <span class="code">MapObjectManager</span><br/>
            A* pathfinding algorithm implementation<br/>
            Map fixtures<br/>
        </td>
    </tr>
    <tr><td class="tb1">Roope</td>
        <td class="tb2">
            <span class="code">Game</span>,
            <span class="code">EventManager</span>,
            <span class="code">GraphicsManager</span>,
            <span class="code">WindowManager</span><br/>
            Game menus and graphics<br/>
        </td>
    </tr>
</table>

<!--
<p>In this chapter you must tell how the task sharing and communication inside the group worked.
You must also tell the real schedule and amount of work done by each group member. You are also encouraged to describe the amount of work of each different part you your project. (planning, implementation of different areas of project, testing and documentation etc.)</p>

<p>Think and tell also, if you could have shared tasks better. What went wrong compared to the schedule of your original
plan and why.</p>
-->

<h2>Differences to the original plan</h2>

<p>
The original plan had us iterating on a basically functional program throughout the development process.
This noble goal was sabotaged by early difficulties in building the administrative and world controller parts,
meaning that in reality, it was a couple of weeks before we were able to scramble together a working iteration.
This also led to challenges when developing the map architecture,
because code sanity checks had to take the form of specially written unit tests
as opposed to just plopping something on the map and seeing if it does what it ought to.
</p>

<!--
<p>In this chapter you must tell what is done in different way that was originally planned and why.</p>

<p>Do you think your plan was good enough, super, or should you have planned your program better?</p>
-->

<h2>References</h2>

<p>In this chapter you must tell all the references you have used during your project.</p>

</body>
</html>

