<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style>
body {
    max-width: 1024px;
    margin: auto;
    font-size: 12pt;
}
.code {
    font-family: monospace;
    font-weight: bold;
    font-size: 10pt;
}
.tb1 {
    vertical-align: top;
    font-weight: bold;
}
.tb2 { vertical-align: top; }
#gamemodes, #tasks {
    width: 80%;
    margin: auto;
}
</style>
<title>AS-0.3302 Project document</title>
</head>

<body>

<div style="text-align: center">
<h3>AS-0.3302 - project document</h3>
<h1>Revenge of the Moon &mdash; The Gathering Storm</h1>
</div>

<h3>Authors:</h3>

<table>
<tr>
<td>84745F</td>
<td>Miro Nurmela</td>
<td><a href="miro.nurmela@aalto.fi">miro.nurmela@aalto.fi</a></td>
</tr>
<tr>
<td>290658</td>
<td>Henri Niva</td>
<td><a href="henri.niva@aalto.fi">henri.niva@aalto.fi</a></td>
</tr>
<tr>
<td>84312L</td>
<td>Joonas Lipping</td>
<td><a href="joonas.lipping@aalto.fi">joonas.lipping@aalto.fi</a></td>
</tr>
<tr>
<td>78740E</td>
<td>Roope Savolainen</td>
<td><a href="roope.savolainen@aalto.fi">roope.savolainen@aalto.fi</a></td>
</tr>
</table>

<h3>Last updated: </h3>

<p>2013-12-12</p>







<h2>Instructions for compiling and use</h2>

<p>
The project should be compiled from the <span class="code">/src</span> folder
with the command <span class="code">make</span>, 
building the default target (<span class="code">all</span>).

To ensure compatibility with school computers,
the default target for <span class="code">make</span>
uses a portable copy of SFML located in the <span class="code">/src/SFML</span> folder.
The <span class="code">alt</span> target for <span class="code">make</span>
attempts to use system libraries instead.

Both targets create an executable titled <span class="code">revenge</span>.
</p>

<p>
You can also compile a simple map editor by running <span class="code">make editor</span>.
This creates an executable called <span class="code">editor</span>, which must be run with
one command line argument. The command line argument defines the name of the map you
are editing. If an existing map is given as an argument you can modify that, otherwise when you save
the map a new file is created. Map names are interpreted relative to the <span class="code">maps</span>
folder.
</p>


<p>
The program opens into a main menu that can be navigated by arrow keys.
The return key selects menu options.
Two game modes are available:
</p>

<table id="gamemodes">
    <tr>
        <td class="tb1"><b>Campaign game</b></td>
         <td class="tb2">
             This is the game's "story mode", consisting of four levels.
             The year is 2061.
             You work at the New Thiggrinc lunar mining colony,
             supplying the precious element MacCuffinium that powers the world economy.
             One day, disaster strikes...
         </td>
    </tr>
    <tr>
        <td class="tb1"><b>Multiplayer game</b></td>
         <td class="tb2">
             Two-player hotseat game in a pre-created map or in a randomly generated map.
             Collect the most scrap to win.
         </td>
    </tr>
</table>

<p>
The campaign game consists of four levels, each with its own
<a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/LargeHam">unapologetically cheesy</a>
story screen (which goes away when you press a button).
The player controls the moon astronaut character with the arrow keys.
There are different terrains on the map, some of which are diggable.
Digging works by "walking into" the target tile.
The map also contains different monsters which will try to damage the player.
Keep away from them or destroy them by using weapons.
Pressing the space bar uses the currently equipped weapon,
and the left alt key changes weapons.
The goal is to get to the next level.
The level exit is located in the upper right corner of the screen.
</p>

<p>
During the level, you will see pieces of scrap lying around.
Collecting scrap lets you craft more items in the Workshop.
After you pass a level, or if you happen to die during the level,
you are taken to the Workshop screen.
You use the same keys in the workshop as you move with, the "fire weapon" key to buy
and the "change weapon" key to sell. Items can be salvaged into the same materials
as they are crafted from.
</p>

<p>
In the multiplayer game mode, the goal is to collect more scrap than the other player
or to destroy the other player. Unlike in the campaign mode, the store is presented
at the start of each round. One player at a time can use the store,
and they use the same keys in the store as they do in the game.
Player 1 uses the arrow keys to move and right Ctrl to fire, right Shift to change weapons;
Player 2 uses the WASD keys to move and Spacebar to fire, left Alt to change weapons.
</p>

<p>
In the editor you can place elements to the map by using your mouse. You can add multiple
blocks by holding the left mouse button and dragging the mouse. You can change the type
of element added by using the appropriate keys shown in the bottom of the screen. Press
<span class="code">s</span> to save to the file you supplied on startup.
</p>

<h3>Screenshots</h3>

<a href="pics/fow.png">
<img src="pics/fow.png" width="200px"/>
</a>
<a href="pics/battle.png">
<img src="pics/battle.png"  width="200px"/>
</a>
<a href="pics/store.png">
<img src="pics/store.png"  width="200px"/>
</a>
<a href="pics/beginning.png">
<img src="pics/beginning.png"  width="200px"/>
</a>
<a href="pics/chased.png">
<img src="pics/chased.png"  width="200px"/>
</a>
<a href="pics/maze_duel.png">
<img src="pics/maze_duel.png"  width="200px"/>
</a>
<a href="pics/overlap_map.png">
<img src="pics/overlap_map.png"  width="200px"/>
</a>
<a href="pics/main_menu.png">
<img src="pics/main_menu.png"  width="200px"/>
</a>

<!--
<p>In this chapter you must tell which platform(s) and operating system(s) your program supports.
How it can be compiled (and installed) ie. which tools are needed to compile the program and which commands to use.
</p>

<p>You must also tell what your program does and how it can be used. You must also add some
example of program runs (example inputs and outputs and/or screenshots or something like that).</p>

<p>Add here the manual of your program.</p>

<p><b>This part is important. If the assistant can not understand how to compile and/or use your program by
reading these instructions, your project will most propably be failed.</b></p>
-->


<h2>Game Mechanics</h2>
<p>
The player control's the character with the selected key set. The character uses the items and
weapons he finds or crafts to slay the enemies and complete the level while collecting treasures
and loot. Most of the enemies deal melee damage to player as a damage per second. All explosions
are instant and all the objects (including players, blocks, items or monsters) within the blast
radius will get damaged. The player can either blow up or mine blocks to navigate through the maps
or reach treasure rooms. The player has a variety of place-down items that have a set fuse time and
explode after the fuse has burned. The player also has two ranged weapons: a flamer, and a rocket
launcher which shoots projectiles. The flames produced by the flamer deal damage per second to
all objects caught in the flames.

</p>


<h3>Items</h3>

<table cellspacing="24px">
    <tr>
        <td >Icon</td>
        <td >Item name</td>
        <td >Cost</td>
        <td >Brief Description</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Small Bomb_icon.png"/></td>
        <td >Small Bomb</td>
        <td >15</td>
        <td >Explodes in a small + pattern with low damage</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Large Bomb_icon.png"/></td>
        <td >Large Bomb</td>
        <td >100</td>
        <td >Explodes in a larger circle pattern. Deals moderate damage.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Crucifix Bomb_icon.png"/></td>
        <td >Crucifix Bomb</td>
        <td >100</td>
        <td >Explodes in a large + pattern. Each directional blast stops at the first metal block.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Large Crucifix Bomb_icon.png"/></td>
        <td >Large Crucifix Bomb</td>
        <td >250</td>
        <td >Explodes in a + pattern that covers the whole screen. Each directional blast stops at the first metal block. Deals massive damage.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Flamer_icon.png"/></td>
        <td >Flamer</td>
        <td >20</td>
        <td >Fires a blast of fire that sets the ground on fire in front of the player. Does not penetrate far into walls. Flames deal damage over time.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Mine_icon.png"/></td>
        <td >Mine</td>
        <td >100</td>
        <td >When deployed, takes two seconds to arm. After the arming time explodes if anything steps into it. Deals massive damage in a small + shape.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Carpet Bomb_icon.png"/></td>
        <td >Carpet Bomb</td>
        <td >75</td>
        <td >After the initial fuse, the carpet bomb will explode and jump into a random cell nearby and explodes again with a very fast fuse. Jumps 6 times in total.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Rocket Launcher_icon.png"/></td>
        <td >Rocket Launcher</td>
        <td >125</td>
        <td >Fires a directed rocket projectile that explodes on contact with anything. Deals moderate damage.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Health Pack_icon.png"/></td>
        <td >Health Pack</td>
        <td >250</td>
        <td >Heals the player for 40 points instantly. Must be activated in game.</td>
    </tr>
    <tr>
        <td ><img src="../src/graphics/items/Pickaxe_icon.png"/></td>
        <td >Pickaxe</td>
        <td >200</td>
        <td >Increases the player's mining speed when in inventory. Effect stacks.</td>
    </tr>
</table>

<p>
TODO: Taulukko vihollisista
</p>




<h2>Program architechture</h2>

<!-- In this chapter you must describe the main architechture of your program. You <b>must draw</b> clear diagrams
of your program structure. You don't need to go in to the details, but this chapter should give the reader
the idea of the architechture of your program. You must also tell, why you decided to use the architechture you used. -->

<p>
The architecture of RotM is conceptually divided, roughly speaking, into four domains.
An administrative system manages resources and handles state transitions.
The map architecture manages the grid-based game levels and their representation,
and the map object system encompasses monsters, treasures, bombs, etc.
The world controller drives the game loop on a given game level.
It can be thought of as a bridge between the administrative system and the map architecture,
because it has properties characteristic of both of these,
but since it is conceptually a separate entity, it is here treated as such.
</p>

<p>This is a simplified architecture diagram showing the key points of the program.<br/><br/><img width="100%" src="pics/program.svg" />.</p>

<h3>The administrative system</h3>

<p>
The entire program is contained within a single <span class="code">Game</span> object.
When it is constsructed, it initializes an
<span class="code">EventManager</span>, a
<span class="code">GraphicsManager</span> and a
<span class="code">TerrainManager</span>.
It makes all three available for other parts of the program throughout its operation.
(The program also makes use of a <span class="code">MapObjectManager</span>,
which is stateless and can therefore just be represented as a two-function namespace
that is globally available (as namespaces are).)
The graphics, terrain, and map object managers are resource managers.
The event manager's function is to handle input events (keyboard commands and window events).
</p>

<p>
After the <span class="code">Game</span> object has taken care of its initial housekeeping,
its member function <span class="code">Game::main()</span> is run.
Excluding game and manager object destructors, this function drives the rest of the program.
The different game states, represented by <span class="code">GameState</span> objects,
form a state stack structure.
When the game starts, a <span class="code">MainMenu</span> state is pushed onto the stack and starts receiving input.
Depending on the user's input, it can spawn a number of different states,
such as <span class="code">SinglePlayerMenu</span>, <span class="code">MultiPlayerMenu</span> or <span class="code">MapEditor</span>.
When such a state is spawned, it gets pushed onto the state stack and becomes the active state.
It remains active until it either spawns another state and transfers control to it,
or terminates and returns control to the state that spawned it.
When the last element on the stack terminates and gets popped, the program terminates &mdash;
that is, when the main menu exits, so does the program.
</p>

<img src="gamestates.svg" width="100%" />

<!--
<p>Comments</p>
-->

<h3>Game managers</h3>

<p>

Game managers (<span class="code">EventManager</span>, <span class="code">GraphicsManager</span>, <span class="code">WindowManager</span>) are responsible from the basic SFML related needs of the game. <span class="code">EventManager</span> handles the initialization of <span class="code">KeyInterfaces</span> and transmitting the input data to the current <span class="code">KeyInterface</span>. <span class="code">GraphicsManager</span> handles the graphics initialization such as loading fonts and textures and creating animations. <span class="code">WindowManager</span> adds a modifiable game specific interface to <span class="code">sf::RenderWindow</span>.
</p>

<h3>The world controller and the map architecture</h3>

<p>
The world controllers (all subclasses of <span class="code">World</span>)
handle the game behavior when the player is actually "in a level".
It calls the update method on each <span class="code">Walker</span> and <span class="code">Item</span>
that the associated <span class="code">Map</span> object contains.
</p>

<p>
A <span class="code">Map</span> is represented as a two dimensional grid (implemented as standard C++
<span class="code">vectors</span>) <span class="code">MapBlocks</span>. Both <span class="code">Map</span> and
<span class="code">MapBlock</span> offer functions and utilites to both get information about the current map
and modify the state of maps and its blocks &mdash; these features are discussed here.

During a game of RoTM the map holds the information about what is going on in the battlefield, such as players,
monsters, items and terrain features. Coincidentially the map blocks also hold the information on who resides in
the given block. More on this on the next chapter.

The <span class="code">Map</span> has a few methods for creating random maps. Specifically, it can create maps
with random rooms and maps with mazes. The generation algorithms are discussed in more detail on the algorithms
section. Other utility algorthms on the map include the computation of line of sight (more on this too on the
algorithms section), radius calculations and various other, simple methods.


</p>

<h3>The map object system</h3>

<p> 
The game level, as represented by the <span class="code">Map</span> and
<span class="code">MapBlock</span> classes, understands its dynamic contents
&mdash; that is, interactive objects beyond simple terrain &mdash;
as <span class="code">Player</span>,
<span class="code">Walker</span> or
<span class="code">Item</span> objects.
Walkers represent characters, mainly monsters, who move around the map at some
given speed. Items represent generally (though not strictly) stationary objects:
collectible treasures, dropped bombs and event-triggering fixtures (and
certain other entities that are not obviously item-like, but are represented as such for convenience,
such as explosions).
Both categories of objects expose an <span class="code">update(dt)</span> method
which the loop of the world controller calls on each pass.
</p>

<p>
<span class="code">Player</span> objects carry information about name, number of lives and inventory,
and are able to spawn walkers as needed to act as avatars.
Players are (from the point of view of the map architecture)
mostly degenerate with walkers, in that most of the time the controller
just wants to access the player's associated walker in order to tell it to update itself.
Players and walkers are handled separately mainly because otherwise there would be no good way to tell
whether a walker is associated with a player, and if so, which one.
</p>

<p>
Usually, a <span class="code">Walker</span> object is also an <span class="code">Actor</span>.
The <span class="code">Actor</span> class, which inherits <span class="code">Walker</span>,
provides additional functionalities of health, digging, etc.
These have been left out of <span class="code">Walker</span> for the sake of generality:
this way, <span class="code">Walker</span> can, if necessary,
act as a subclass for objects such as projectiles, for which digging
and health are not meaningful properties.
<span class="code">Actor</span> is further inherited by
<span class="code">ControlledActor</span> and <span class="code">AIActor</span>,
which represent keyboard-controlled and computer-controlled characters,
respectively.
Controlled actors provide methods that other objects can use to
inform them of the controller state (which keys are pressed),
while AI actors use an internal logic, managed by their <span class="code">update()</span>
methods, that "plans ahead" what they're going to do.
In general, when an AI actor is updated, it follows its existing plan if it has one;
if the plan runs out, it calls its <span class="code">think()</span>
method, which hatches a new one.
</p>

<p>
<span class="code">Item</span> objects are almost entirely self-organizing.
Their constructors automatically add them to the relevant <span class="code">Map</span>
and <span class="code">MapBlock</span>, and their destructors remove them from the same.
They only need to be <span class="code">new</span>ed and <span class="code">delete</span>d "by hand".
Walkers handle their map tiles on their own,
but the map's set of walkers needs to be "garbage collected" by another routine.
</p>







<h2>Data structures and algorithms</h2>

<h3>General data structures</h3>

<p>
The project uses a standard associative container <span class="code">std::map</span>
as well as <span class="code">std:;vector</span> in many places.
In <span class="code">Map</span> and <span class="code">MapBlock</span>
objects, however, the walkers and items that they contain are represented as a <span class="code">std::set</span>.
The set provides logarithmic inserts, erases and lookups, which is perfect for the use case.
Paths of <span class="code">MapBlock</span>s are represented as <span class="code">deque</span>s.
</p>


<h3>Map generation algorithms</h3>

RotM sports two kinds of random map generation algorithms - one that creates random rooms and one that
creates random mazes. The random room algorithm works as follows:

<ol>
    <li>Create borders for the map</li>
    <li>Fill the map with empty blocks</li>
    <li>Create a single room somewhere on the map with random terrain walls</li>
    <li>Randomly decide a new room to add</li>
    <li>Try adding the feature</li>
    <li>If adding failed, go to step 3</li>
    <li>Otherwise, add feature</li>
    <li>Go to step 3 if the stoppping condition has not been met</li>
    <li>Throw in some items randomly on the map</li>
</ol>

The maze generation algorithm works by recursively dividing rooms into smaller rooms. This results
in good mazes gameplaywise (enough room to maneuver). The algorithm works as follows:

<p>
<span class="code">define divide(x_min, x_max, y_min, y_max)</span><br/>
&nbsp;&nbsp;<span class="code">if (x_max - x_min smaller than threshold or y_max - y_min smaller than threshold)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">return</span><br/>
&nbsp;&nbsp;<span class="code">horizontal = randInt % 2</span><br/>
&nbsp;&nbsp;<span class="code">if (horizontal)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">add a wall at random y coordinate between y_min and y_max and add door somewhere in the wall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x_max, y_min, y)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x_max, y, y_max)</span><br/>
&nbsp;&nbsp;<span class="code">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">add a wall at random x coordinate between x_min and x_max and add door somewhere in the wall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x_min, x, y_min, y_max)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code">divide(x, x_max, y_min, y_max)</span><br/>
</p>

<p>
There are some additional checks in the algorithm to ensure that the doors are not blocked, but this is the basic
idea of the algorithm.
</p>

<h3>Line of sight algorithm</h3>

<p>
The program calculates the line of sight using a modified vestion of Bresenham's line algorithm (see the
<a href="#refs">references</a> for a reference). The original Bresenham's algorithm twists the numbres
around such that it can always increment the value that loops through the pixels - we don't want this
kind of behaviour, since we want all the lines to start from the player (and not end there, as would
be the case of some view lines if we were to use the original Bresenham's algorithm). In practice the
program tries to draw a line to every border block and as long as there is nothing on the way, it marks
those blocsk visible. Drawing of the line ends as soon as it hits something impassable.
)
</p>

<h3>A* pathfinding algorithm</h3>

<p>
<span class="code">A*</span> is a widely used graph search algorithm.
In this case, it is being used to find paths for AI purposes,
in order to plot courses from monster to player (and possibly some other tasks).
The nodes of the "graph" are the <span class="code">MapBlock</span>s, and the edge weights are
determined by the passability of the blocks (moving into a passable block has a cost of 1).
</p>

<p>
The algorithm treats each map block as a node with a given "projected cost" value,
which is path "already traveled distance" cost and part heuristic (minimum cost to destination).
The algorithm is based around a priority queue of these nodes.
On each iterative step, the node with the lowest projected cost is popped from the priority queue.
If it is the goal node, the algorithm is finished.
If not, all its hitherto unvisited neighbors are pushed onto the priority queue.
</p>

<p>
Both pushes and pops are O(log n) operations, due to the heaplike structure of the priority queue.
If the nodes in the priority queue run out, then there is no path from source to destination.
Otherwise, as long as the heuristic satisfies one elementary condition
(namely, the projected cost with the heuristic must never be so large that it is possible for
a path with a smaller actually confirmed cost to exist),
the first time that the goal node is popped is guaranteed to represent the <em>shortest</em>
possible path, given the constraints.
</p>

<h3>AI monster animations</h3>

<p>
An interesting approach is used to make the paths that AI monsters take when "wandering" look natural.
Basically, when the monster sees no player in range, it cycles through a "move" step and a "sleep" step.
In the "move" step, the monster picks a reachable map block within a given distance at random,
then moves to it along the shortest path. (This two-step method is chosen in favor of directly using a random walk because
it ensures that the monster won't saw back and forth between two blocks, which looks really stupid.) 
In the "sleep" step, the monster stands still in the same place for a randomized amount of time.
This is again because the AI movement would look very restless and not at all organic
if the monsters were <em>always</em> going somewhere.
</p>

<p>
With this approach, AI actors have a natural-looking "wander" behavior.
</p>


<h2>Known bugs</h2>

<p>
<ol>
    <li>Not strictly a bug, but the editor's code quality is terrible and it lacks features (you might notice that you can't place monsters, for example). This might be fixed by tomorrow.</li>
    <li> <span class="code">sf::Text</span> leaks memory because the destructor of it chrashes the game. Therefore all the <span class="code">sf::Text</span> are stored in a map in <span class="code">GraphicsManager</span> to have them all in the same place and to keep them alive, until the game ends. This is a known <a href="#refs">SFML-bug</a>.</li>
    <li>After a game finishes, the enter key (select menu item function) is sometimes unresponsive (but it works eventually).</li>
    <li>The final level of the campaign is not yet finished. The boss character has not been made, and there is no victory condition.</li>
    <li>On some machines, story screens have gotten stuck if the window is not in focus (mouse is elsewhere etc.) when the story screen is shown.
        If you encounter this problem, klick the screen before you navigate to "Single Player" and "Start" to ensure that the window has focus.</li>
    <li>There are some rare simultaneous death conditions (e.g., bug and player at the same time) that cause the game to segfault.
        It is likely that this is because of confusion in the <span class="code">World</span> controller loop's garbage collection routine getting confused.</li>
    <li>The rocket launcher does not always travel correctly. Occasionally, the rocket explodes right away, detonating in the player's face.</li>
</ol>
</p>

<!--
<p>In this chapter you must tell all known bugs in your code. You must also tell what could have been done better.</p>

<p>If the assistant finds bug(s) in your code that you haven't mentioned, it is very bad thing and your points will be
decreased. And if your code segfaults, it is even worse and your points will be decreased more...</p>
-->

<h2>Tasks sharing and schedule</h2>

<table id="tasks">
    <tr><td class="tb1">Miro</td>
        <td class="tb2">
            <span class="code">Map</span> and <span class="code">MapBlock</span> implementations<br/>
            Map generation (stuff lives in <span class="code">Map</span>)<br/>
            Line of sight (in <span class="code">MapUtils</span>)<br/>
            Map editor (in <span class="code">MapEditor</span> and <span class="code">EditorInterface</span>)<br/>
            Fixes and additions around the program<br/>
        </td>
    </tr>
    <tr><td class="tb1">Henri</td>
        <td class="tb2">
	    <span class="code">Item</span> class and most of its derivates, such as
        <span class="code">Weapons</span>,<br/> animations and effects.<br/>
	    <span class="code">Inventory</span> and <span class="code">Store</span> implementations.<br/>
	    Game graphics.<br/>
        </td>
    </tr>
    <tr><td class="tb1">Joonas</td>
        <td class="tb2">
            <span class="code">Walker</span> and all inheriting classes; <span class="code">Player</span>; enemy AI<br/>
            <span class="code">GameState</span> base class and mechanism; <span class="code">CampaignGame</span><br/>
            <span class="code">KeyInterface</span> base class and mechanism; <span class="code">PlayerInterface</span><br/>
            <span class="code">TerrainManager</span>, 
            <span class="code">MapObjectManager</span><br/>
            A* pathfinding algorithm implementation<br/>
            Map fixtures<br/>
        </td>
    </tr>
    <tr><td class="tb1">Roope</td>
        <td class="tb2">
            <span class="code">Game</span>,
            <span class="code">EventManager</span>,
            <span class="code">GraphicsManager</span>,
            <span class="code">WindowManager</span><br/>
            <span class="code">Menu</span> and inheriting classes: <span class="code"> MainMenu</span>,<span class="code"> SinglePlayerMenu</span>, <span class="code"> MultiPlayerMenu</span> <br/>

            Game graphics<br/>
        </td>
    </tr>
</table>

<!--
<p>In this chapter you must tell how the task sharing and communication inside the group worked.
You must also tell the real schedule and amount of work done by each group member. You are also encouraged to describe the amount of work of each different part you your project. (planning, implementation of different areas of project, testing and documentation etc.)</p>

<p>Think and tell also, if you could have shared tasks better. What went wrong compared to the schedule of your original
plan and why.</p>
-->

<h2>Differences to the original plan</h2>

<p>
The original plan had us iterating on a basically functional program throughout the development process.
This noble goal was sabotaged by early difficulties in building the administrative and world controller parts,
meaning that in reality, it was a couple of weeks before we were able to scramble together a working iteration.
This also led to challenges when developing the map architecture,
because code sanity checks had to take the form of specially written unit tests
as opposed to just plopping something on the map and seeing if it does what it ought to.
</p>

<p>
Most of the ambitious extra goals mentioned in the plan were not implemented. They were omitted due to time
constraints and also in effort to focus on making the basic gameplay better. I'm pretty sure, for example,
that the current map generation methods don't fall to the criteria of being "super cool".
</p>

<!--
<p>In this chapter you must tell what is done in different way that was originally planned and why.</p>

<p>Do you think your plan was good enough, super, or should you have planned your program better?</p>
-->
<div id="refs">
    <h2>References</h2>

    <p>In this chapter you must tell all the references you have used during your project.</p>

    <p>Bresenham's line algorihm, <a href="http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Wikipedia on Bresenham's line algorithm</a>, read 11.12.2013</p>
    <p>Things about maze generation, <a href="http://en.wikipedia.org/wiki/Maze_generation_algorithm">Wikipedia on maze generation</a>, read 11.12.2013</p>
    <p>Ideas on map generation, <a href="http://pcg.wikidot.com/pcg-algorithm:dungeon-generation">Dungeon generation algorithms</a>, read 11.12.2013</p>
    <p>A* pathfinding algorithm, <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia</a>, read 12.12.2013</p>
    <p>sf::Text issues, <a href="http://en.sfml-dev.org/forums/index.php?topic=6901.0">Forum discussion</a>, <a href="https://github.com/LaurentGomila/SFML/issues/329">SFML issues</a>, read 12.12.2013</p>
</div>

<h2>Gameplay pictures</h2>
<a href="pics/fow.png">Fog of war and line of sight</a><br/>
<a href="pics/battle.png">Battle!</a><br/>
<a href="pics/store.png">Store</a><br/>
<a href="pics/beginning.png">Beginning of campaign</a><br/>
<a href="pics/chased.png">Hero chased by critters</a><br/>
<a href="pics/maze_duel.png">Duel in a maze</a><br/>
<a href="pics/overlap_map.png">Ovelapping random map</a><br/>
<a href="pics/main_menu.png">Main menu</a><br/>

</body>
</html>

